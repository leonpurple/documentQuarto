---
title: "Design Patterns"
---
![Pincipios SOLID y patrones de Dise帽o](/images/designpatterns/image-designpatterns.png){.preview-image}

## 驴 Por que usar Desing Patterns...?

"Los patrones de dise帽o en Java son una herramienta esencial para cualquier desarrollador. Mejoran la calidad del c贸digo al proporcionar soluciones estandarizadas y reutilizables a problemas comunes en el desarrollo de software. Al utilizarlos, los desarrolladores pueden reducir la cantidad de c贸digo duplicado, mejorar la legibilidad y la mantenibilidad del c贸digo y hacer que el desarrollo sea m谩s eficiente y organizado. 隆Optimiza tu c贸digo con patrones de dise帽o en Java! "


## Los 5 patrones de dise帽o m谩s utilizados en Java son:

::: {.summary}
 **Developer skills summary**

- Patr贸n de Singleton
- Patr贸n de Fabrica
- Patr贸n de Estrategia
- Patr贸n Observer
- Patr贸n Decorador
:::

---

- Patr贸n de Singleton: Asegura que una clase solo tenga una instancia y provee un punto de acceso global a ella.

- Patr贸n de Fabrica: Define una interfaz para crear objetos en una superclase, pero deja que las subclases decidan qu茅 clases crear.

- Patr贸n de Estrategia: Define una familia de algoritmos, encapsula cada uno y los hace intercambiables.

- Patr贸n de Observer: Define una dependencia uno-a-muchos entre objetos, de manera que cuando un objeto cambia su estado, todos sus dependientes son notificados y actualizados autom谩ticamente.

- Patr贸n de Decorador: Anade responsabilidades a objetos din谩micamente en tiempo de ejecuci贸n.

---
## Ejemplos de c贸digo con Patrones de Dise帽o
---

::: {.panel-tabset}
## Singleton

``` {.java}


public class Singleton {
  private static Singleton instance = null;

  private Singleton() {}

  public static Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    return instance;
  }

}



 En este ejemplo, la clase Singleton contiene
 una 煤nica propiedad est谩tica llamada instance,
 que es una instancia de la clase Singleton.
 La clase tiene un constructor privado para 
 evitar que la clase sea instanciada
 por cualquier otra parte del c贸digo.

La clase tiene un m茅todo est谩tico llamado 
getInstance que es el 煤nico punto de
acceso a la instancia de la clase. 
Si la propiedad instance todav铆a es null,
se crea una nueva instancia de la clase Singleton.
De lo contrario, se retorna la instancia existente.

Este patr贸n garantiza que la clase solo tenga
una 煤nica instancia, lo que asegura que los datos 
compartidos en la aplicaci贸n sean consistentes y seguros.



```

## Fabrica

``` {.java}

Ejemplo de c贸digo de Patr贸n de Dise帽o de f谩brica en Java:

interface Shape {
   void draw();
}

class Circle implements Shape {
   @Override
   public void draw() {
      System.out.println("Se dibuja un c铆rculo");
   }
}

class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Se dibuja un rect谩ngulo");
   }
}

class Square implements Shape {
   @Override
   public void draw() {
      System.out.println("Se dibuja un cuadrado");
   }
}

class ShapeFactory {
   public Shape getShape(String shapeType) {
      if (shapeType == null) {
         return null;
      }
      if (shapeType.equalsIgnoreCase("CIRCLE")) {
         return new Circle();
      } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
         return new Rectangle();
      } else if (shapeType.equalsIgnoreCase("SQUARE")) {
         return new Square();
      }
      return null;
   }
}

class FactoryPatternDemo {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      Shape shape1 = shapeFactory.getShape("CIRCLE");
      shape1.draw();

      Shape shape2 = shapeFactory.getShape("RECTANGLE");
      shape2.draw();

      Shape shape3 = shapeFactory.getShape("SQUARE");
      shape3.draw();
   }
}





Este c贸digo ilustra una implementaci贸n 
b谩sica del patr贸n de dise帽o de f谩brica en Java.
La clase ShapeFactory es una f谩brica que
produce objetos de diferentes tipos de formas.
En el m茅todo getShape de la clase ShapeFactory,
se determina qu茅 tipo de forma se desea crear 
en funci贸n del argumento shapeType.
Luego, se devuelve la forma apropiada.
El programa principal en la clase FactoryPatternDemo 
usa la f谩brica para crear diferentes
objetos de formas y dibujar los objetos.





```

## Estrategia

```{.java}

Ejemplo de c贸digo utilizando el Patr贸n de Dise帽o Estrategia 

import java.util.ArrayList;
import java.util.List;

interface Strategy {
    int doOperation(int num1, int num2);
}

class AdditionStrategy implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1 + num2;
    }
}

class SubtractionStrategy implements Strategy {
    @Override
    public int doOperation(int num1, int num2) {
        return num1 - num2;
    }
}

class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public int executeStrategy(int num1, int num2) {
        return strategy.doOperation(num1, num2);
    }
}

public class StrategyPatternExample {
    public static void main(String[] args) {
        List<Context> contexts = new ArrayList<>();
        contexts.add(new Context(new AdditionStrategy()));
        contexts.add(new Context(new SubtractionStrategy()));

        for (Context context : contexts) {
            System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
            System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
        }
    }
}


El patr贸n de dise帽o de estrategia permite 
seleccionar una estrategia de entre
varias posibles al resolver un problema,
de manera que se puedan cambiar las estrategias
en tiempo de ejecuci贸n sin tener que modificar
el c贸digo que utiliza la estrategia.
En este ejemplo, el contexto es el que
selecciona la estrategia para realizar 
una operaci贸n matem谩tica espec铆fica
(suma o resta), y el c贸digo que utiliza
la estrategia no necesita conocer los
detalles de c贸mo se realiza la 
operaci贸n, s贸lo invoca el m茅todo
executeStrategy del contexto.


```

## Observer

```{.java}
Ejemplo de c贸digo en Java para uso de Patron Observer

import java.util.ArrayList;
import java.util.List;

interface Observer {
    void update();
}

interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

class ConcreteObserver implements Observer {
    private int state;

    @Override
    public void update() {
        // Actualizar el estado del observador con el estado del sujeto
    }

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
    }
}

class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private int state;

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }

    public int getState() {
        return state;
    }

    public void setState(int state) {
        this.state = state;
        notifyObservers();
    }
}

public class ObserverPatternExample {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        ConcreteObserver observer1 = new ConcreteObserver();
        ConcreteObserver observer2 = new ConcreteObserver();

        subject.registerObserver(observer1);
        subject.registerObserver(observer2);

        subject.setState(5);

        System.out.println("Observer 1: " + observer1.getState());
        System.out.println("Observer 2: " + observer2.getState());
    }
}

El patr贸n de dise帽o Observer permite que un objeto,
conocido como sujeto, notifique a sus dependientes,
conocidos como observadores, cuando su estado cambia.
En este ejemplo, el sujeto es ConcreteSubject y 
los observadores son ConcreteObserver.
El sujeto mantiene una lista de observadores registrados,
y los notifica a todos cuando su estado cambia,
invocando el m茅todo update de cada uno.
Los observadores actualizan su propio estado
en respuesta a la notificaci贸n.



```

## Decorador



```{.java}

interface Component {
    String operation();
}

class ConcreteComponent implements Component {
    @Override
    public String operation() {
        return "Concrete Component";
    }
}

abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public String operation() {
        return component.operation();
    }
}

class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public String operation() {
        return "Concrete Decorator A (" + super.operation() + ")";
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public String operation() {
        return "Concrete Decorator B (" + super.operation() + ")";
    }
}

public class DecoratorPatternExample {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        System.out.println("Result: " + component.operation());

        component = new ConcreteDecoratorA(component);
        System.out.println("Result: " + component.operation());

        component = new ConcreteDecoratorB(component);
        System.out.println("Result: " + component.operation());
    }
}

El patr贸n de dise帽o Decorador permite agregar
din谩micamente responsabilidades adicionales a un objeto.
En este ejemplo, la interfaz Component define 
la operaci贸n a decorar y la clase ConcreteComponent
implementa la operaci贸n sin ninguna decoraci贸n.
Las clases ConcreteDecoratorA y ConcreteDecoratorB
son decoradores que agreguen responsabilidades
adicionales a la operaci贸n original.
En la funci贸n main, se crea un objeto
ConcreteComponent y se lo decoran con ConcreteDecoratorA
y ConcreteDecoratorB para ver c贸mo cambia la operaci贸n.
```
:::


